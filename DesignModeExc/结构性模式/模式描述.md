#  模式描述

## 结构型描述

* 描述如何实现类或则对象的组合 *

## 1. 外观模式

定义：

    定义一个高层接口，为子系统中的一组接口提供统一的接口。外观模式又称门面模式。

使用场景：

    1.子系统随着业务复杂度的提升而变得越来越复杂，客户端需要某些子系统共同协作来完成某个任务
    2.在多层结构的系统中，使用外观对象可以作为每层的入口来简化层间的调用。

成员：

    1. 客户端类：外观类知晓各个子系统的职责和接口，封装子系统的接口并提供给客户端
    2. 外观类： 外观类知晓各个子系统的职责和接口，封装子系统的接口并提供给客户端
    3. 子系统类：子系统类实现子系统的功能，对外观类一无所知

优点：

    1.实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。
    2.符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。

缺点：
   
    违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。

应用：

> SDWebImage 封装了负责图片下载的类和负责图片缓存的类，而外部仅向客户端暴露了简约的下载图片的接口
> 直播间的应用，连麦，弹幕，抽奖，礼物，推拉流，聊天，动画效果，都属于直播间的子系统

## 2.适配器模式 (Adapter)

定义：
    
    将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能在一起工作的那些类可以在一起工作。适配器模式的别名是 包装器模式。

分类：
1. 对象适配器：利用组合的方式将请求转发给被适配者。
2. 类适配器：通过适配器类多重继承目标接口和被适配者，将目标方法的调用转接到调用被适配者的方法。
    
使用场景：
    
    1.想使用一个已经存在的类，但是这个类的接口不符合我们的要求，原因可能是和系统内的其他需要合作的类不兼容。
    2.想创建一个功能上可以复用的类，这个类可能需要和未来某些未知的类一起工作。
    
成员：
    
    1、目标：客户端希望直接接触的类，给客户端提供了调用的接口。
    2、被适配者：被适配者是已经存在的类，即需要被适配的类。
    3、适配器：适配器对被适配者的接口和目标接口进行适配。

优点：
    
    1.符合开闭原则：使用适配器而不需要改变现有类，提高类的复用性。
    2.目标类和适配器类解耦，提高程序扩展性。

缺点：
    
    增加了系统的复杂性
    
## 3. 桥接模式

定义：
    
    将抽象部分与它的实现部分分离，使它们都可以独立地变化。

定义解读：
     桥接模式的核心就是两个抽象以组合的形式关联到一起，从而它们的实现就互不依赖了。

适用场景：

    如果一个系统存在两个独立变化的维度，而且这两个维度都需要进行扩展的时候比较适合使用桥接模式。


成员：

    抽象类：抽象类维护一个实现部分的对象的引用，并声明调用实现部分的对象的接
    扩展抽象类：扩展抽象类定义跟实际业务相关的方法。
    实现类接口：实现类接口定义实现部分的接口
    具体实现类：具体实现类是实现实现类接口的对象。
    
优点：

    扩展性好，符合开闭原则：将抽象与实现分离，让二者可以独立变化

缺点：
   
    在设计之前，需要识别出两个独立变化的维度。

## 4.代理模式

定义：
    
    为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。

定义解读：
    使用代理模式以后，客户端直接访问代理，代理在客户端和目标对象之间起到中介的作用。

成员：

    客户端：客户端意图访问真实主体接口
    抽象主题：定义客户端需要访问的接口
    代理：代理继承于抽象主题，目的是为了它持有真实目标的实例的引用，客户端直接访问代理
    真是主题：被代理的对象，它也继承于抽象主题，它的实例被代理所持有，它的接口被包装在了代理的接口中，而且客户端无法直接访问真实的主题对象。

优点：

    降低系统耦合度，协调调用者和被调用者，在一定程度上降低了系统的耦合度。

缺点：
    
    由于在客户端和被代理对象之间增加了代理对象，可能会让客户端的请求速度变慢。
    
## 5.装饰者模式

定义：
    
    不改变原有对象的前提下，动态的给一个对象增加一些额外的功能。

使用场景：

    1.动态地给一个对象增加职责（功能），这些职责（功能）也可以动态地被撤销。
    2.当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时。

成员：

    抽象构件：抽象构件定义一个对象（接口），可以动态地给这些对象添加职责
    具体构件：具体构件是抽象构件的实例。
    装饰：装饰类也继承于抽象构件，它持有一个具体构件对象的实例，并实现一个与抽象构件接口一致的接口。
    具体装饰：具体装饰负责给具体构建对象实例添加上附加的责任。
    
优点：
    
    1.比继承更加灵活：不同于在编译期起作用的继承；装饰者模式可以在运行时扩展一个对象的功能。另外也可以通过配置文件在运行时选择不同的装饰器，从而实现不同的行为。
    也可以通过不同的组合，可以实现不同效果。
    2.符合“开闭原则”：装饰者和被装饰者可以独立变化。用户可以根据需要增加新的装饰类，在使用时再对其进行组合，原有代码无须改变。
    
缺点：

    装饰者模式需要创建一些具体装饰类，会增加系统的复杂度


## 6.享元模式

定义：
    
    运用共享技术复用大量细粒度的对象，降低程序内存的占用，提高程序的性能

定义解读：
    1.享元模式的目的就是使用共用技术来实现大量细粒度对象的复用，提高性能
    2.享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。
        1> 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。
        2> 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。
        一个外部状态与另一个外部状态之间是相互独立的。

使用场景：
    
    1.系统有大量的相似对象，这些对象有一些外在状态
    2.应当在多次重復使用享元对象时才值得使用享元模式，因为享元模式需要维护一个存储享元对象的享元池，这需要消耗性能

成员：

    享元工厂：享元工厂提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象
    抽象享元：抽象享元定义了具体享元对象需要实现的接口。
    具体享元：具体享元实现了抽象享元类定义的接口。
    

优点：
   
    1.使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。
    2.享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

缺点：
    
    1.使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
    2.对象在缓冲池中的复用需要考虑线程问题。

应用：

    iOS SDK中的UITableViewCell的复用池就是使用享元模式的一个例子

### 构造型模式做个总结：

> 外观模式：提供各种独立的接口，按需调用；
> 适配器模式：上层接口名称不变，只是改变了接口的实现；
> 桥接模式：将2个抽象类组合到一起，即一个持有另外一个；
> 代理模式：将数据给到代理，或者由我的代理执行事件；
> 装饰着模式：装饰着持有被装饰着，进行装饰；
> 享元模式：复用已经创建好的对象，在对这个对象做其他设置；
