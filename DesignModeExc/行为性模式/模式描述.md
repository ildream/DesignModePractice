#  模式描述

## 行为型描述：

* 类或者对象怎样交互以及怎样分配职责 *

## 1.模板方法模式

定义：
    
    定义一个操作中的算法的框架，而将一些步骤的执行延迟到子类中，使得子类可以在不改变算法的结构的前提下即可重新定义该算法的某些特定步骤。

适用场景：
    
    1.通常一个算法需要几个执行步骤来实现，而有时我们需要定义几种执行步骤一致，但是却可能在某个步骤的实现略有差异的算法。
    也就是说我们既需要复用实现相同的步骤，也可以通过在某个步骤的不同实现来灵活扩展出更多不同的算法。
    2.在这种场景下，我们可以使用模板方法模式：定义好一个算法的框架，在父类实现可以复用的算法步骤，而将需要扩展和修改其他步骤的任务推迟给子类进行。

成员：

    客户端: 和具体算法类直接接触的类
    算法类：负责声明算法接口，算法步骤接口。并实现可复用的算法步骤接口，且将需要子类实现的接口暴露出来。
    具体算法类：负责实现算法类声明的算法步骤接口。
    
优点：

    1. 复用性高：将相同的代码放在父类中，而不同的部分则由子类实现
    2. 扩展性高：可以通过创建不同的子类扩展不同的算法
    3. 符合开闭原则：可变与不可变的部分分离，而且不同的可变部分也是分离的，所以符合了开闭原则

缺点：
    
    1. 导致类的个数增加：对于每一个算法实现都需要一个子类，如果实现过多的话会导致类的个数增加
    2. 由继承关系导致的缺点：如果父类增加或则减少它的行为，则所有的子类都需要同步修改一次

应用：

    iOS中，UIView 的drawRect方法可以自定义绘图，是模板方法模式的一种实践
    

## 2.策略模式

定义：
    
    定义一系列的算法，将每一个算法封装起来，并让它们可以互相替换。
    
适用场景：
    
    有时候在实现某一个功能的时，可能会有多个方案，我们需要让系统可以动态灵活的更换方案，而且也能够让开发者方便的增加新的方案或者删除旧的方案。
    如果我们将所有的方案硬编码在同一个类中，那么今后修改，添加，删除某个方案的时候就会改动原有类，这违反了开闭原则。
    其实我们可以定义一些独立的类来封装不同的解决方案，每一个类封装一个具体的方案，这些不同的方案就是我们所说的策略。
    而且我们可以用一个抽象的策略类来保证这些策略的一致性，这就是策略模式的设计方案。
    
成员：

    环境类：内部持有一个具体策略类的实例，这个实例就是当前的策略，可以供给客户端使用
    抽象策略类： 声明具体策略类需要实现的接口，这个接口同时也是提供给客户端调用的接口
    具体策略类：实现抽象策略类声明的接口，每个具体策略类都有自己独有的实现方式，即代表不同策略

优点：

    1.策略模式遵循开闭原则，用户可以在不修改原有系统的前提下选择和更换算法
    2.避免使用多重条件判断
    3.可以灵活地增加新的算法或行为
    4.提高算法和策略的安全性：可以封装策略的具体实现，调用者只需要知道不同策略之间的区别就可以

缺点：
    
    1.客户端必须知道当前所有的具体策略类，而且需要自行决定使用哪一个策略类
    2.如果可选的方案过多，会导致策略类数量激增。

## 3.职责链模式

定义：
    
    避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式
    
适用场景：
    
    在处理某个请求的时候，解决策略因条件不同而不同。这时，相对于使用if-else来区分不同的条件和对应的解决策略，
    我们可以使用责任链模式，将不同条件和对应的解决策略封装到一个类中，即不同的处理者。然后将这些处理者组成责任链，
    在当前处理者无法处理或不符合当前条件时，将请求传递给下一个处理者。
    
成员：
    
    客户端：
    处理者：定义处理接口
    具体处理者：实现处理者声明的接口，负责处理请求

优点：
    
    1.处理者之间的责任分离，处理者只要处理好自己的逻辑即可
    2.方便修改每个处理者的处理逻辑，也方便删除或者添加处理者，或者改变责任链中处理者的顺序。

缺点：

    因为需要在责任链上传递责任，直到找到合适的对象来处理，所以可能会导致处理的延迟。因此在延迟不允许过高的场景下不适合使用责任链模式。

应用：
    
    iOS SDK中的响应者莲就是职责链模式的实践: 如果当前视图无法响应则传递给下一层级视图。
    
    

## 4.状态模式

定义：
    
    允许一个对象在其内部改变状态时，改变它的行为。

适用场景：
    
    1.一个对象存在多个状态，不同状态下的行为会有不同，而且状态之间可以相互转换。
    2.如果我们通过if else来判断对象的状态，那么代码中会包含大量与对象状态有关的条件语句，而且在添加，删除和更改这些状态的时候回比较麻烦；
    而如果使用状态模式。将状态对象分散到不同的类中，则可以消除 if...else等条件选择语句。
    3.状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，
    所以对象在不同状态下具有不同行为时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。
    
成员：
    
    环境类：引用具体状态实例。环境类持有的具体状态就是当前的状态，可以通过set方法将状态实例注入到环境类中。
    抽象状态类：声明具体状态类需要实现的接口
    具体状态类：实现抽象状态类声明的接口

优点：
    
    1.封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中
    2.将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。
    3.允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。
    4.可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
    
缺点：
    
    1.状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。
    2.状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。
    3.状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。

    
    
## 5.命令模式

定义：
    
    命令（或者请求）被封装成对象。客户端将命令（或请求）对象先传递给调用对象。调用对象把把该命令（或请求）对象传递给合适的，可处理该命令（或请求）的对象来做处理。

定义解读：
    由定义可以看出，在命令模式中，命令被封装成了对象，而发送命令的客户端与处理命令的接收者中间被调用对象隔开了，这种设计的原因或者适用的场景是什么样的呢？

使用场景：
    
    在有些场景下，任务的处理可能不是需要立即执行的：可能需要记录（日至），撤销或重试（网络请求）。
    那么在这些场景下，如果任务的请求者和执行者是紧耦合状态下的话就可能会将很多其他执行策略的代码和立即执行的代码混合到一起。
    
    这些其他执行策略，我们暂时称之为控制和管理策略，而如果我们如果想控制和管理请求，就需要：
    1.把请求抽象出来
    2.让另外一个角色来负责控制和管理请求的任务

    因此命令模式就是为此场景量身打造的，它通过：
    把请求封装成对象
    使用调用者在客户端和请求处理者之间来做一个“拦截”，方便对请求对象做控制和管理。

成员：
    
    抽象命令类：负责声明命令接口
    具体命令类：负责实现抽象命令声明的接口
    调用者：负责将具体命令的实例传递给接受者
    接受者：负责处理命令

优点：
    
    1.将命令的发起者和命令的执行者分离，降低系统的耦合度
    2.便于批量处理命令，比如日至队列的实现；便于命令的撤销或重试，比如网络请求等
缺点：

    需要针对每一个命令创建一个命令对象。如果系统中的命令过多，会造成系统中存在大量的命令类，提高系统的复杂度。

## 6.观察者模式

定义：

    定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都可以得到通知并做相应针对性的处理。
    观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。
    观察者模式是一种对象行为型模式。

成员：

    目标：是被观察的角色，声明添加和删除观察者以及通知观察者的接口。
    具体目标：实现目标类声明的接口，保存所有观察者的实例（通过集合的形式）。在被观察的状态发生变化时，给所有登记过的观察者发送通知。
    观察者：定义具体观察者的更新接口，以便在收到通知时实现一些操作。
    具体观察者：实现抽象观察者定义的更新接口。

优点：
    
    1.观察者模式在观察目标和观察者之间建立了一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。
      由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
    2.可实现广播的一对多的通信

缺点：

    1.如果一个观察目标对象有很多直接和间接的观察者的话，会需要比较多的通信时间。
    2.需要注意观察者和观察目标之间是否有循环引用。

应用：
    
    iOS SDK中的KVO 与 NSNotification 是观察者模式的应用。


## 7.中介者模式(mediator)

定义：
    
    用一个中介者对象来封装一系列的对象交互，中介者使各对象之间不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。

使用场景：

    系统结构可能会日益变得复杂，对象之间存在大量的相互关联和调用，系统的整体结构容易变为网状结构。
    在这种情况下，如果需要修改某一个对象，则可能会要跟踪和该对象关联的其他所有对象，并进行处理。耦合越多，修改的地方就会越多。
    如果我们使用中介者对象，则可以将系统的网状结构变成以中介者为中心的星型结构。
    中介者承担了中转作用和协调作用，简化了对象之间的交互，而且还可以给对象间的交互进行进一步的控制。

成员：
    
    抽象中介者：定义具体中介者需要实现的接口。
    具体中介者：实现抽象中介者定义的接口，承担多个具体同事类之间的中介者的角色。
    抽象同事类：定义具体同事类需要实现的接口。
    具体同事类：实现抽象同事类定义的接口。

优点：
    
    1.中介者使得各对象不需要显式的相互引用，从而使其解耦松散.
    中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。
    2.中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，
    一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。
    
缺点：

    在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。     
    

## 8.迭代器模式

定义：
    
    提供一种方法来访问聚合对象，而不是暴露这个对象内部的表示，迭代器模式是一种对象行为模式
    
使用场景：
     迭代器帮助请求方获取数据，避免直接操作数据聚合类，使数据聚合类专注存储数据。具体应用有分页等功能，分页功能的迭代器将专门负责操作分页数据，将操作逻辑和数据源分离
     
成员：

    iterator(迭代器接口类): 该接口必须定义实现迭代功能的最小定义方法集，比如提供hasNext()和next()方法
    ConcreteIterator(迭代器实现类): 迭代器接口iterator的实现类。
    Aggregate(容器接口)：定义基本功能以及提供类似Iterator的iterator()方法。
    ConcreteAggregate（容器实现类）: 容器接口的实现类，必须实现Iterator的iterator()方法。
     
优点：
    
    1.它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，
    我们也可以自己定义迭代器的子类以支持新的遍历方式。
    2.迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计

缺点：

    1.由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
    2.抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，
    如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，
    创建一个考虑全面的抽象迭代器并不是件很容易的事情

## 9.备忘录模式

定义：
    
    保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。

    意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
    何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。
    如何解决：通过一个备忘录类专门存储对象状态。
    关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。
    应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。
    优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。
    缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
    使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作

成员：
   
    orginator(原发器)：负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。
                      同时原发器还可以根据需要决定Memento存储Originator的那些内部状态。
    memento(备忘录)：用于存储Originator的内部状态，并且可以防止Originator以外的对象访问Memento。
                   在备忘录Memento中有两个接口，其中Caretaker只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。
                    Originator可以看到宽接口，允许它访问返回到先前状态的所有数据。
    caretaker(负责人)：负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。
    
优点：
    
    1.给用户提供了一种可以恢复状态的机制。可以是用户能够比较方便地回到某个历史的状态。
    2.实现了信息的封装。使得用户不需要关心状态的保存细节。
    
缺点：
    
    消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
    
    
    

